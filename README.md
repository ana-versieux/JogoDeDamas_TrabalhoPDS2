Jogo de Damas
1) Como compilar e executar
2) Arquitetura / organização

   O jogo é dividido em diferentes pastas: .vscode, documentação, include, src e o Doxyfile. Em .vscode é possível encontrar detalhes das configurações e compilações, tendo em vista que todo o trabalho foi escrito na plataforma VS code e, depois, transferido por meio dos commits para o Git Hub. Em documentação é possível encontrar dois arquivos: html e latex, que possuem dados do projeto. Na pasta include, há os arquivos .hpp, sendo eles “jogo.hpp”, “peca.hpp” e “tabuleiro.hpp”, possuindo as classes necessárias para o funcionamento do jogo. Na pasta src há 3 arquivos, o “jogo.cpp”, onde há todo o processo para que o jogo ocorra, o Makefile com suas definições e “tabuleiro.cpp”, com todas as funções para que o tabuleiro seja feito. Além disso, há o Doxyfile, com as descrições das configurações utilizadas no jogo. Cada arquivo do código será detalhado no decorrer do ReadMe.

3) Funcionalidades entregues e itens fora do escopo

   O arquivo “tabuleiro.hpp” define a classe “Tabuleiro”, que representa o tabuleiro fixo de 8x8 casas do jogo. Ele armazena as peças em uma matriz e oferece métodos para adicionar, remover, mover e acessar peças, além de verificar se uma posição está vazia ou inválida. O método “desenharTabuleiro()” exibe o estado atual do jogo e o método “inicializarCasas()” prepara o tabuleiro para iniciar outra jogada.
   O arquivo “peca.hpp” contém a classe “Peca”, que representa cada peça individualmente. Nela está armazenado a posição, cor (branca ou preta) e se é uma dama. Possui métodos para mover, promover a dama, consultar posição e cor, e verificar se o movimento é permitido. A estrutura “Posicao” ajuda no controle das coordenadas. As cores das peças também são usadas para determinar os dois lados do jogo.
   O arquivo “jogo.hpp” define a classe “Jogo”, que controla a lógica da partida. É responsável por iniciar o jogo, processar e validar jogadas, alternar turnos, promover peças e verificar o fim da partida. Um objeto “Tabuleiro” é usado internamente e controla o turno atual e o estado do jogo, se está ativo ou encerrado.
   O Makefile foi criado para compilar os arquivos “peca.cpp”, “tabuleiro.cpp”, “jogo.cpp” e “main.cpp” para gerar o executável damas. O alvo “all” compila o programa e remove os arquivos temporários, enquanto o alvo “run” recompila, limpa a tela e executa o jogo.
   O Doxygen foi usado para gerar a documentação automática do código.

   O arquivo tabuleiro.cpp implementa a lógica principal de uma classe chamada Tabuleiro, que representa o tabuleiro de um jogo, provavelmente de damas ou xadrez. Essa classe gerencia as posições das peças dentro de uma matriz bidimensional, onde cada célula pode conter uma peça (Peca*) ou estar vazia (nullptr). O tabuleiro tem um tamanho fixo, definido pela constante TAMANHO_TABULEIRO, e todas as operações feitas sobre ele respeitam esse limite.
   Quando um objeto Tabuleiro é criado, seu construtor chama a função inicializarCasas. Essa função percorre todas as posições da matriz e define cada casa como nullptr, o que significa que o tabuleiro começa completamente vazio. Essa etapa é importante para evitar ponteiros aleatórios ou restos de memória de execuções anteriores.
   O método desenharTabuleiro é responsável por exibir o estado atual do tabuleiro no terminal. Ele imprime primeiro as letras das colunas (A, B, C, etc.) e depois as linhas numeradas. Em cada casa, o método verifica se há uma peça. Se a casa estiver vazia, imprime um espaço; caso haja uma peça, ele consulta a cor e o tipo da peça por meio dos métodos getCor() e ehDama() da classe Peca. As peças brancas são representadas por letras minúsculas (b para peças normais e B para damas), enquanto as peças pretas usam letras minúsculas (p) ou maiúsculas (P), dependendo do tipo. Dessa forma, o jogador pode visualizar facilmente o tabuleiro e distinguir as peças de acordo com sua cor e status.
   Para adicionar uma peça ao tabuleiro, existe a função adicionarPeca, que recebe um ponteiro para uma peça (Peca*). Essa função só insere a peça se ela for válida (ou seja, diferente de nullptr), se a posição dela estiver dentro dos limites do tabuleiro, e se a casa correspondente estiver vazia. Se essas condições forem satisfeitas, a peça é colocada na matriz, e a casa passa a apontar para aquele objeto. É importante destacar que essa operação não cria uma nova peça, apenas associa ao tabuleiro um ponteiro para uma peça já existente.
   Para remover uma peça, a classe oferece o método removerPeca, que recebe as coordenadas da casa que se deseja limpar. Caso a posição seja válida, a função usa o comando delete para liberar a memória associada à peça naquela posição e, em seguida, define o ponteiro como nullptr. Essa função, portanto, assume que o tabuleiro é o dono das peças e é responsável por liberar sua memória. Esse detalhe é importante: se outro código tentar usar o ponteiro de uma peça já deletada, haverá erro. Por isso, uma forma mais segura de implementar essa lógica seria usar ponteiros inteligentes, como std::unique_ptr.
   A função getPeca serve para acessar a peça de uma determinada posição. Ela retorna o ponteiro para a peça se as coordenadas forem válidas; caso contrário, devolve nullptr. Assim, o programa pode verificar o conteúdo de uma casa sem modificá-lo. Complementarmente, o método estaVazio devolve um valor booleano indicando se a casa está vazia ou não, o que facilita verificações antes de tentar mover ou adicionar peças.
   O método moverPeca implementa a movimentação de peças dentro do tabuleiro. Ele recebe as coordenadas de origem e destino, e realiza o movimento somente se ambas as posições forem válidas, se existir uma peça na origem e se o destino estiver vazio. Quando essas condições são atendidas, a peça é retirada da posição de origem, atualiza internamente sua própria posição através do método moverPara, e depois é colocada na nova posição do tabuleiro. A função não apaga nem cria novas peças — apenas as move dentro da matriz. Também não verifica se    o movimento é permitido segundo as regras do jogo; essa responsabilidade deve estar em outro módulo do programa.
   Por fim, o método posicaoValida é uma pequena função auxiliar que verifica se as coordenadas passadas estão dentro dos limites do tabuleiro. Ele retorna verdadeiro se o valor de x e y estiver entre zero e o tamanho máximo do tabuleiro, e falso caso contrário. Essa verificação é usada em praticamente todas as outras funções da classe, garantindo que o programa não tente acessar posições fora dos limites da matriz, o que causaria erros de execução.
   Em resumo, o código de tabuleiro.cpp define uma estrutura robusta e organizada para controlar o estado de um tabuleiro de jogo. Ele é responsável por armazenar, exibir, mover e remover peças, garantindo a integridade do tabuleiro e a validade das operações básicas. A classe não contém as regras específicas do jogo (como movimentos válidos, capturas ou promoções), mas fornece todas as ferramentas necessárias para que essas regras possam ser implementadas em outro nível da aplicação. O código é bem estruturado e funcional, embora pudesse ser aprimorado com práticas modernas de C++, como o uso de ponteiros inteligentes para evitar vazamentos de memória e uma melhor distinção de erros ou tentativas inválidas de movimentação.

   É em “jogo.cpp” que a partida é coordenada. O tabuleiro é inicializado, as entradas dos usuários são processadas, os movimentos são validados, as jogadas são aplicadas, as peças que chegam são coroadas e é detectado o fim do jogo. O método para processar a jogada: verifica se o jogo ainda está ativo, faz a validação da entrada (por meio de validarEntrada, verificando algum erro), valida a jogada por meio de jogadaValida, aplica a jogada com aplicarJogada (movendo a peça e, se houver, remove a capturada), promove a peça a dama se chegou à última linha, por meio de transformarEmDama, checa fim de jogo com jogoAcabou e, caso tenha acabado, imprime o vencedor por meio de getVencedor, desenha e encerra a partida. Depois, o turno é alterado e o tabuleiro redesenhado.
   Em validarEntrada, é garantido que o formato está em sua forma correta, utilizando Tabuleiro::posicaoValida para limites do tabuleiro, enviando invalid_argument com mensagens quando algo está fora do esperado. Já em jogadaValida as regras são checadas: se existe peça na origem, se o turno está correto (cor deve coincidir com o turnoAtual_), se o destino está vazio e se o movimento é diagonal.  Em casos de peça comum com passo 1 (movimento simples absDx == 1), se não for dama, a branca só pode mover para frente e, retorna peca->podeMover(dx,dy) para delegar o detalhe do movimento à peça. Em caso de captura com salto 2 (peça comum absDx == 2), a casa do meio é checada. Deve existir uma peça adversária ali, se for aliada, é inválido, caso contrário, retorna true (captura válida). Em caso de Dama (movimento “deslizante” em diagonal, qualquer distância), o caminho diagonal é percorrido e é contado quantas peças existem no meio. Se for maior que 1 peça no caminho, é inválido, não podendo saltar sobre mais de uma. Se houver 1 peça no caminho: caso a peça é aliada, é inválido e, caso é inimiga, a captura é válida. Se não houverem peças no caminho, o movimento simples é válido. Isso permite com que a dama ande livremente sem capturar, quando o caminho está limpo, e capture uma peça por lance.
   Em aplicarJogada, é calculada a direção e caminho da orig ao dest. A primeira peça encontrada no caminho, caso houver, é removida, efetivando a captura. Por fim, chama tabuleiro_.moverPeca. Em alterarTurno() há uma troca de Branca <-> Preta. Em transformarEmDama, se a peça não é dama, a branca vira dama quando alcançar y == TAMANHO_TABULEIRO -1 e a preta vira dama quando alcançar y == 0; Peca -> setToDama é chamado e uma mensagem é imprimida.
   Em jogoAcabou() const e getVencedor() const, ambos contam quantas peças brancas e pretas existem no tabuleiro. jogoAcabou retorna true se uma das cores ficou sem peças e getVencedor retorna BRANCA se há alguma branca, caso contrário, retorna PRETA.
   Em “jogo.cpp” foi utilizado de entrada textual no formato A3-B4 com conversão para índices de matriz; exceções std::invalid_argument para validar formato/posições; principais regras de damas; fluxo de jogo organizado; ponteiros para peças e um contêiner Tabuleiro que oferece operações, e mensagens de erro claras para guiar o jogador.

4) Instruções de uso
5) Tratamento de exceções / programação defensiva
6) Documentação (Doxygen)
7) Link do vídeo
8) Equipe

   A Equipe é composta por 4 integrantes: Ana Versieux Mota, Helena Quintão Utsch, Maria Luiza Alvim Avelar e Sofia Gomes de Oliveira. No decorrer do trabalho, atuamos em conjunto para o seu desenvolvimento. Todo o trabalho foi escrito no VS code, plataforma que utilizamos para desenvolver o código e commitar o que foi feito no GitHub. Semanalmente nos reuníamos para discutir o que seria melhor e melhorar o nosso código em conjunto. Íamos escrevendo no VS code para que, quando estivesse pronto e todas tivessem aprovado tudo, iríamos commitar no GitHub. 
Dividimos o trabalho em algumas partes, que foi de responsabilidade das integrantes do grupo e, à medida que o projeto foi sendo feito, iríamos analisando e realizando mudanças em seu corpo. A Ana contribuiu em todo o projeto e, inicialmente atuou na parte de documentações e também na ideação do jogo e seus funcionamentos. No decorrer do projeto ajudou em todas as interfaces e, focou mais em seus commits referentes aos arquivos do main e também da peça. A Helena contribuiu em todo o projeto e, inicialmente atuou na criação do arquivo do tabuleiro. No decorrer do projeto ajudou em todas as interfaces e, focou mais em seus commits referentes ao arquivo do jogo e o readme. A Maria contribuiu em todo o projeto e, inicialmente atuou na parte de criação das pastas e também na ideação do jogo e seus funcionamentos. No decorrer do projeto ajudou em todas as interfaces e, focou mais em seus commits referentes aos arquivos hpp e Makefile. A Sofia contribuiu em todo o projeto e, inicialmente atuou na parte da peça. No decorrer do projeto ajudou em todas as interfaces e, focou mais em seus commits referentes aos arquivos do tabuleiro e parte do jogo. 
Todas as integrantes foram migrando em diferentes partes com o intuito de que o trabalho ficasse de acordo com a opinião de todas. Além disso, realizamos ele de forma mais dinâmica buscando um melhor resultado.

9) Ciclo de Desenvolvimento (sprints) e aprendizados
10) Linha do tempo das sprints

    Todas as entregas foram organizadas e suas datas colocadas conforme as datas no calendário do professor. Utilizamos do VS code com o intuito de escrever o código por completo e commitar quando as partes estiverem com um escopo pronto, com o intuito de ter uma organização melhor em relação ao GitHub. O objetivo principal foi focar no código escrito e que ele esteja de acordo com o padrão que estávamos buscando, como seu envio feito no dia limite da entrega, para que nos organizássemos melhor em relação aos prazos.
    Entrega inicial: até dia 09/10: Definição do tema e acesso ao GitHub.
    Entrega parcial: até o dia 23/10: Estrutura dos diretórios, requisitos de modelagem e definição de contratos.
    Entrega final: até o dia 11/11: Finalização dos códigos, implementação dos contratos, documentação, incrementos, finalização e vídeo. 

11) Planejado x Realizado
    
   Inicialmente, não tínhamos certeza do que seria desenvolvido. Após uma análise em conjunto, resolvemos criar um jogo, pois esse tipo de mecanismo é utilizado por todas as integrantes do grupo. A partir dessa decisão, começamos a planejar o funcionamento e o desenvolvimento de um Jogo de Damas.
   O projeto foi conduzido conforme o planejado, com uma arquitetura modular e bem organizada. As pastas include, src, documentação, .vscode e Doxyfile foram estruturadas desde o início, abrigando os arquivos necessários para o funcionamento do jogo. As classes Peca, Tabuleiro e Jogo foram implementadas de acordo com o que foi definido: Peca representa cada peça individual, Tabuleiro controla o estado do jogo e o posicionamento das peças, e Jogo coordena toda a lógica da partida, validando jogadas, alternando turnos e verificando o fim do jogo.   
   O arquivo tabuleiro.cpp foi desenvolvido conforme o planejado, contendo as funções de inicialização, desenho, movimentação e remoção de peças, além de verificações de posição. O Makefile foi configurado corretamente para compilar e executar o programa, e o Doxygen foi utilizado para gerar a documentação técnica.
   De forma geral, o que foi planejado — um jogo de damas funcional, documentado e estruturado — foi plenamente realizado. O resultado final atendeu às expectativas e prazos definidos, demonstrando organização, aprendizado e trabalho em equipe.
    
13) Evidências no GitHub
