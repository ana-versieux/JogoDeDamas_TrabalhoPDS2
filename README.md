Jogo de Damas
1) Como compilar e executar
2) Arquitetura / organização

   O jogo é dividido em diferentes pastas: .vscode, documentação, include, src e o Doxyfile. Em .vscode é possível encontrar detalhes das configurações e compilações, tendo em vista que todo o trabalho foi escrito na plataforma VS code e, depois, transferido por meio dos commits para o Git Hub. Em documentação é possível encontrar dois arquivos: html e latex, que possuem dados do projeto. Na pasta include, há os arquivos .hpp, sendo eles “jogo.hpp”, “peca.hpp” e “tabuleiro.hpp”, possuindo as classes necessárias para o funcionamento do jogo. Na pasta src há 3 arquivos, o “jogo.cpp”, onde há todo o processo para que o jogo ocorra, o Makefile com suas definições e “tabuleiro.cpp”, com todas as funções para que o tabuleiro seja feito. Além disso, há o Doxyfile, com as descrições das configurações utilizadas no jogo. Cada arquivo do código será detalhado no decorrer do ReadMe.

3) Funcionalidades entregues e itens fora do escopo

   O arquivo “tabuleiro.hpp” define a classe “Tabuleiro”, que representa o tabuleiro fixo de 8x8 casas do jogo. Ele armazena as peças em uma matriz e oferece métodos para adicionar, remover, mover e acessar peças, além de verificar se uma posição está vazia ou inválida. O método “desenharTabuleiro()” exibe o estado atual do jogo e o método “inicializarCasas()” prepara o tabuleiro para iniciar outra jogada.
   O arquivo “peca.hpp” contém a classe “Peca”, que representa cada peça individualmente. Nela está armazenado a posição, cor (branca ou preta) e se é uma dama. Possui métodos para mover, promover a dama, consultar posição e cor, e verificar se o movimento é permitido. A estrutura “Posicao” ajuda no controle das coordenadas. As cores das peças também são usadas para determinar os dois lados do jogo.
   O arquivo “jogo.hpp” define a classe “Jogo”, que controla a lógica da partida. É responsável por iniciar o jogo, processar e validar jogadas, alternar turnos, promover peças e verificar o fim da partida. Um objeto “Tabuleiro” é usado internamente e controla o turno atual e o estado do jogo, se está ativo ou encerrado.
   O Makefile foi criado para compilar os arquivos “peca.cpp”, “tabuleiro.cpp”, “jogo.cpp” e “main.cpp” para gerar o executável damas. O alvo “all” compila o programa e remove os arquivos temporários, enquanto o alvo “run” recompila, limpa a tela e executa o jogo.
   O Doxygen foi usado para gerar a documentação automática do código.

   O arquivo "tabuleiro.cpp" implementa a classe "Tabuleiro", responsável por representar e gerenciar o tabuleiro de um jogo de damas. Ele define a estrutura do tabuleiro como uma matriz de ponteiros para peças e oferece métodos para controlar todo o funcionamento do jogo. Ao ser instanciado, o tabuleiro é inicializado pelo construtor, que chama o método "inicializarCasas()", responsável por preencher todas as posições com valores nulos, indicando que estão vazias. O método "desenharTabuleiro()" imprime o tabuleiro no console de forma visual, exibindo colunas identificadas por letras e linhas por números, além de mostrar as peças de acordo com sua cor e se são damas ou não. A classe também possui funções para adicionar e remover peças, garantindo que apenas posições válidas e vazias sejam utilizadas. O método "moverPeca()" permite deslocar uma peça de uma posição de origem para um destino, atualizando a matriz de casas e a posição da peça. Além disso, o método "getPeca()" retorna o ponteiro para uma peça em determinada posição, e "estaVazio()" verifica se uma casa está livre. Por fim, a função "posicaoValida()" assegura que as coordenadas fornecidas estejam dentro dos limites do tabuleiro. Em resumo, o código define toda a lógica de controle e exibição do tabuleiro, servindo como a base estrutural para o funcionamento do jogo.

   É em “jogo.cpp” que a partida é coordenada. O tabuleiro é inicializado, as entradas dos usuários são processadas, os movimentos são validados, as jogadas são aplicadas, as peças que chegam são coroadas e é detectado o fim do jogo. O método para processar a jogada: verifica se o jogo ainda está ativo, faz a validação da entrada (por meio de validarEntrada, verificando algum erro), valida a jogada por meio de jogadaValida, aplica a jogada com aplicarJogada (movendo a peça e, se houver, remove a capturada), promove a peça a dama se chegou à última linha, por meio de transformarEmDama, checa fim de jogo com jogoAcabou e, caso tenha acabado, imprime o vencedor por meio de getVencedor, desenha e encerra a partida. Depois, o turno é alterado e o tabuleiro redesenhado.
   Em validarEntrada, é garantido que o formato está em sua forma correta, utilizando Tabuleiro::posicaoValida para limites do tabuleiro, enviando invalid_argument com mensagens quando algo está fora do esperado. Já em jogadaValida as regras são checadas: se existe peça na origem, se o turno está correto (cor deve coincidir com o turnoAtual_), se o destino está vazio e se o movimento é diagonal.  Em casos de peça comum com passo 1 (movimento simples absDx == 1), se não for dama, a branca só pode mover para frente e, retorna peca->podeMover(dx,dy) para delegar o detalhe do movimento à peça. Em caso de captura com salto 2 (peça comum absDx == 2), a casa do meio é checada. Deve existir uma peça adversária ali, se for aliada, é inválido, caso contrário, retorna true (captura válida). Em caso de Dama (movimento “deslizante” em diagonal, qualquer distância), o caminho diagonal é percorrido e é contado quantas peças existem no meio. Se for maior que 1 peça no caminho, é inválido, não podendo saltar sobre mais de uma. Se houver 1 peça no caminho: caso a peça é aliada, é inválido e, caso é inimiga, a captura é válida. Se não houverem peças no caminho, o movimento simples é válido. Isso permite com que a dama ande livremente sem capturar, quando o caminho está limpo, e capture uma peça por lance.
   Em aplicarJogada, é calculada a direção e caminho da orig ao dest. A primeira peça encontrada no caminho, caso houver, é removida, efetivando a captura. Por fim, chama tabuleiro_.moverPeca. Em alterarTurno() há uma troca de Branca <-> Preta. Em transformarEmDama, se a peça não é dama, a branca vira dama quando alcançar y == TAMANHO_TABULEIRO -1 e a preta vira dama quando alcançar y == 0; Peca -> setToDama é chamado e uma mensagem é imprimida.
   Em jogoAcabou() const e getVencedor() const, ambos contam quantas peças brancas e pretas existem no tabuleiro. jogoAcabou retorna true se uma das cores ficou sem peças e getVencedor retorna BRANCA se há alguma branca, caso contrário, retorna PRETA.
   Em “jogo.cpp” foi utilizado de entrada textual no formato A3-B4 com conversão para índices de matriz; exceções std::invalid_argument para validar formato/posições; principais regras de damas; fluxo de jogo organizado; ponteiros para peças e um contêiner Tabuleiro que oferece operações, e mensagens de erro claras para guiar o jogador.

4) Instruções de uso
5) Tratamento de exceções / programação defensiva
6) Documentação (Doxygen)
7) Link do vídeo
8) Equipe

   A Equipe é composta por 4 integrantes: Ana Versieux Mota, Helena Quintão Utsch, Maria Luiza Alvim Avelar e Sofia Gomes de Oliveira. No decorrer do trabalho, atuamos em conjunto para o seu desenvolvimento.
9) Ciclo de Desenvolvimento (sprints) e aprendizados
10) Linha do tempo das sprints
11) Planejado x Realizado
12) Evidências no GitHub
